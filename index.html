<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <!-- Torna a p√°gina responsiva para dispositivos m√≥veis -->
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Pr√°tica: Pilhas com Lista Encadeada</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f4f4f4;
      padding: 20px;
      margin: 0;
    }
    h1 { color: #333; }
    .pergunta {
      margin-bottom: 20px;
      padding: 15px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 0 5px #ccc;
    }
    .opcao {
      display: block;
      margin: 5px 0;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
      background: #eee;
      cursor: pointer;
    }
    .opcao:hover {
      background: #ddd;
    }
    .feedback {
      margin-top: 10px;
      font-style: italic;
    }
    #resultado {
      margin-top: 30px;
      font-weight: bold;
      font-size: 1.2em;
    }
    #proximaBtn {
      margin-top: 15px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      display: none;
    }
    .macete { font-weight: bold; }
    
    @keyframes cair {
      0% { transform: translateY(-100%); opacity: 0; }
      100% { transform: translateY(0); opacity: 1; }
    }
    #codigoAnimado {
      white-space: pre-wrap;
      animation: cair 2s ease-in;
      background: #222;
      color: #0f0;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 5px #0f0;
    }
  </style>
</head>
<body>
  <!-- √Årea de apresenta√ß√£o -->
  <div id="apresentacao" style="background:#000; color:#0f0; font-family:monospace; padding:20px; border-radius:8px; margin-bottom:20px;">
    <pre id="codigoAnimado"></pre>
    <h2 style="margin-top:20px;">üìò Pilhas com Lista Encadeada</h2>
    <p>A pilha funciona no estilo <strong>LIFO</strong> (Last In, First Out). Ou seja, o √∫ltimo valor inserido ser√° o primeiro a ser removido. Usando listas encadeadas, conseguimos implementar essa estrutura de forma din√¢mica usando ponteiros.</p>
    <p>Aqui v√£o 5 <strong style="color:yellow;">macetes piscantes</strong> para mandar bem:</p>
    <ul id="macetes">
      <li class="macete">1Ô∏è‚É£ Sempre inicialize o topo com NULL.</li>
      <li class="macete">2Ô∏è‚É£ Use malloc/new ao empilhar (aloca√ß√£o din√¢mica).</li>
      <li class="macete">3Ô∏è‚É£ Ao desempilhar, libere mem√≥ria com free/delete.</li>
      <li class="macete">4Ô∏è‚É£ Nunca acesse topo->valor sem verificar se topo != NULL.</li>
      <li class="macete">5Ô∏è‚É£ Para percorrer a pilha, use while (topo != NULL).</li>
    </ul>
    <button onclick="iniciarQuestoes()" style="margin-top:20px; padding:10px 20px; font-size:16px; cursor:pointer; background:#0f0; color:#000; border:none; border-radius:5px;">
      üëâ Iniciar Quest√µes
    </button>
  </div>

  <!-- √Årea do Quiz -->
  <div id="quizContainer" style="display:none;">
    <h1>Estudo de Pilhas com Lista Encadeada</h1>
    <p>Responda cada quest√£o. Voc√™ saber√° na hora se acertou ou errou. No final, ver√° o total de acertos.</p>
    <div id="quiz"></div>
    <button id="proximaBtn" onclick="mostrarProxima()">Pr√≥xima</button>
    <div id="resultado"></div>
  </div>

  <script>
    // Fun√ß√£o para iniciar o quiz: esconde apresenta√ß√£o e exibe o quiz
    function iniciarQuestoes() {
      document.getElementById('apresentacao').style.display = 'none';
      document.getElementById('quizContainer').style.display = 'block';
      mostrarQuestao();
    }

    // Array de quest√µes
    const questoes = [
      { pergunta: "O que √© uma pilha na estrutura de dados?", opcoes: ["FIFO", "Banco de dados", "LIFO", "Fun√ß√£o recursiva"], correta: 2, explicacao: "Pilha segue o princ√≠pio LIFO: o √∫ltimo elemento inserido √© o primeiro a sair." },
      { pergunta: "Qual opera√ß√£o insere um elemento no topo da pilha?", opcoes: ["Pop", "Top", "Push", "Peek"], correta: 2, explicacao: "Push √© a opera√ß√£o que insere um novo elemento no topo da pilha." },
      { pergunta: "Qual opera√ß√£o remove o elemento do topo da pilha?", opcoes: ["Push", "Peek", "Insert", "Pop"], correta: 3, explicacao: "Pop remove o elemento que est√° no topo da pilha." },
      { pergunta: "O que a fun√ß√£o 'verTopo' retorna?", opcoes: ["Total de elementos", "Valor do topo", "Remove topo", "Insere elemento"], correta: 1, explicacao: "verTopo retorna o valor do n√≥ no topo sem remov√™-lo." },
      { pergunta: "Como identificamos uma pilha vazia?", opcoes: ["Topo aponta pro √∫ltimo", "Pop retorna zero", "Topo √© nulo", "Todos apontam para nullptr"], correta: 2, explicacao: "Se o ponteiro do topo for nulo, a pilha est√° vazia." },
      { pergunta: "O que o ponteiro 'pr√≥ximo' de um n√≥ armazena?", opcoes: ["Valor atual", "Quantidade", "Pr√≥ximo n√≥", "Topo da pilha"], correta: 2, explicacao: "Ele armazena o endere√ßo do pr√≥ximo n√≥ na lista." },
      { pergunta: "Como inicializar a pilha vazia?", opcoes: ["Topo aponta pro √∫ltimo", "Topo = nullptr", "Topo = 0", "Remover todos os elementos"], correta: 1, explicacao: "Atribu√≠mos nullptr ao topo da pilha." },
      { pergunta: "O que faz a fun√ß√£o 'exibirPilha'?", opcoes: ["Adiciona um n√≥", "Mostra todos os elementos", "Busca um valor", "Libera mem√≥ria"], correta: 1, explicacao: "Ela percorre a pilha e exibe seus valores." },
      { pergunta: "O que acontece com o antigo topo ap√≥s um empilhar?", opcoes: ["√â exclu√≠do", "Vai pro fim", "Vira pr√≥ximo do novo topo", "Vira n√≥ base"], correta: 2, explicacao: "O novo n√≥ aponta para o antigo topo." },
      { pergunta: "Por que usamos ponteiro por refer√™ncia na fun√ß√£o empilhar?", opcoes: ["Evitar aloca√ß√£o", "Copiar valor", "Modificar o topo fora da fun√ß√£o", "Retornar valor"], correta: 2, explicacao: "Passando por refer√™ncia, alteramos o topo real." },
      { pergunta: "O que acontece se desempilharmos com pilha vazia?", opcoes: ["Empilha nulo", "Erro + -1", "Nada acontece", "Finaliza programa"], correta: 1, explicacao: "Mostra erro e retorna -1." },
      { pergunta: "Resultado da sequ√™ncia: empilha 5, empilha 10, desempilha, empilha 20, verTopo?", opcoes: ["5", "10", "20", "Erro"], correta: 2, explicacao: "√öltimo valor empilhado √© 20." },
      { pergunta: "Ordem ap√≥s empilhar 10, 20, 30?", opcoes: ["10 -> 20 -> 30", "30 -> 20 -> 10", "NULL <- 10", "30 <- 20 <- 10"], correta: 1, explicacao: "Novo elemento vai sempre no topo." },
      { pergunta: "Por que retornamos -1 em verTopo se vazio?", opcoes: ["Para desalocar", "Reiniciar pilha", "Indicar sem valor", "Evitar execu√ß√£o"], correta: 2, explicacao: "√â uma forma de aviso que n√£o h√° valor." },
      { pergunta: "Como a pilha encadeada √© eficiente?", opcoes: ["Acesso direto a qualquer n√≥", "Todos t√™m o mesmo valor", "N√£o usa ponteiros", "Opera√ß√µes s√≥ no topo"], correta: 3, explicacao: "S√≥ manipulamos o topo, o que √© r√°pido." },
      { pergunta: "Fun√ß√£o 'pilhaVazia' retorna o qu√™?", opcoes: ["true se topo == nullptr", "false sempre", "true se topo != nullptr", "Erro"], correta: 0, explicacao: "Verifica se o topo aponta pra nada." },
      { pergunta: "No c√≥digo: empilhar(topo, 10); empilhar(topo, 20); desempilhar(topo); verTopo(topo); qual valor?", opcoes: ["10", "20", "NULL", "30"], correta: 0, explicacao: "20 foi removido, 10 √© o topo." },
      { pergunta: "Por que empilhar aloca dinamicamente?", opcoes: ["Evitar ponteiro", "Manter o tamanho fixo", "Criar novo n√≥ na mem√≥ria", "Liberar mem√≥ria"], correta: 2, explicacao: "Cada push cria um novo n√≥ com new." },
      { pergunta: "Que parte da struct armazena o valor da pilha?", opcoes: ["Ponteiro", "Valor", "Topo", "NULL"], correta: 1, explicacao: "Campo 'valor' guarda a informa√ß√£o do n√≥." },
      { pergunta: "Por que chamamos a estrutura de n√≥?", opcoes: ["Por ser circular", "Porque encadeia outros n√≥s", "Por n√£o usar ponteiros", "Por conter apenas dados"], correta: 1, explicacao: "Cada n√≥ aponta para outro, criando a cadeia." },
      { pergunta: "Como √© feita a exibi√ß√£o da pilha?", opcoes: ["Do fim ao topo", "Recursivamente", "Iterando do topo at√© NULL", "Aleatoriamente"], correta: 2, explicacao: "Percorremos a partir do topo at√© o fim." },
      { pergunta: "Qual tipo usamos na struct No?", opcoes: ["int e No*", "char e int", "float e string", "int apenas"], correta: 0, explicacao: "int valor e No* proximo." },
      { pergunta: "O que o topo aponta ap√≥s desempilhar?", opcoes: ["Pro novo elemento", "Pro n√≥ removido", "Pro pr√≥ximo do antigo topo", "NULL"], correta: 2, explicacao: "Topo agora aponta para o pr√≥ximo n√≥." },
      { pergunta: "Qual √© o retorno da fun√ß√£o desempilhar?", opcoes: ["Valor removido", "Endere√ßo de mem√≥ria", "Novo topo", "NULL"], correta: 0, explicacao: "Ela retorna o valor que estava no topo." },
      { pergunta: "Quando usar pilha encadeada em vez de array?", opcoes: ["Quando o tamanho √© fixo", "Para otimizar busca", "Quando o tamanho da pilha √© vari√°vel", "Para armazenar strings"], correta: 2, explicacao: "Pilha encadeada cresce dinamicamente." },
      { pergunta: "Por que liberar mem√≥ria ao desempilhar?", opcoes: ["Para resetar topo", "Evitar vazamento de mem√≥ria", "Remover valor", "Evitar erro"], correta: 1, explicacao: "Precisamos deletar o n√≥ que foi removido." },
      { pergunta: "Quantos ponteiros s√£o necess√°rios na struct No?", opcoes: ["2", "1", "0", "3"], correta: 1, explicacao: "Apenas um ponteiro para o pr√≥ximo n√≥." },
      { pergunta: "Qual sa√≠da da fun√ß√£o exibirPilha ap√≥s push 5, 10, 15?", opcoes: ["5 -> 10 -> 15", "15 -> 10 -> 5", "NULL", "Erro"], correta: 1, explicacao: "15 foi o √∫ltimo inserido, est√° no topo." },
      { pergunta: "Em que situa√ß√£o o topo da pilha ser√° NULL?", opcoes: ["Quando cheia", "Ap√≥s √∫ltimo pop", "Quando cheia de inteiros", "Quando empilhar"], correta: 1, explicacao: "Pilha vazia: topo = NULL." },
      { pergunta: "Qual sa√≠da para verTopo se pilha est√° vazia?", opcoes: ["0", "NULL", "-1", "Erro"], correta: 2, explicacao: "Retorna -1 para indicar aus√™ncia de valor." }
    ];

    let indiceAtual = 0;
    let acertos = 0;

    const quiz = document.getElementById('quiz');
    const proximaBtn = document.getElementById('proximaBtn');
    const resultado = document.getElementById('resultado');

    function mostrarQuestao() {
      quiz.innerHTML = '';
      proximaBtn.style.display = 'none';
      resultado.innerText = '';

      const q = questoes[indiceAtual];
      const div = document.createElement('div');
      div.className = 'pergunta';
      div.innerHTML = `<p><b>Quest√£o ${indiceAtual + 1}:</b> ${q.pergunta}</p>`;
      q.opcoes.forEach((opcao, i) => {
        const botao = document.createElement('button');
        botao.textContent = opcao;
        botao.className = 'opcao';
        botao.onclick = () => verificarResposta(i, q);
        div.appendChild(botao);
      });
      quiz.appendChild(div);
    }

    function verificarResposta(resposta, q) {
      const botoes = document.querySelectorAll('.opcao');
      botoes.forEach(btn => btn.disabled = true);
      const feedback = document.createElement('p');
      feedback.className = 'feedback';
      if (resposta === q.correta) {
        feedback.style.color = 'green';
        feedback.textContent = '‚úîÔ∏è Resposta correta!';
        acertos++;
      } else {
        feedback.textContent = `‚ùå Resposta incorreta. Explica√ß√£o: ${q.explicacao}`;
      }
      quiz.appendChild(feedback);
      proximaBtn.style.display = 'inline-block';
    }

    function mostrarProxima() {
      indiceAtual++;
      if (indiceAtual < questoes.length) {
        mostrarQuestao();
      } else {
        quiz.innerHTML = '';
        proximaBtn.style.display = 'none';
        resultado.innerText = `Voc√™ acertou ${acertos} de ${questoes.length} quest√µes.`;
      }
    }

    // Anima√ß√£o do c√≥digo exemplo
    const codigoExemplo = `struct No {
  int valor;
  No* proximo;
};

void empilhar(No*& topo, int valor) {
  No* novo = new No;
  novo->valor = valor;
  novo->proximo = topo;
  topo = novo;
}`;

    let i = 0;
    const areaCodigo = document.getElementById('codigoAnimado');
    function escreverCodigo() {
      if (i < codigoExemplo.length) {
        areaCodigo.textContent += codigoExemplo.charAt(i);
        i++;
        setTimeout(escreverCodigo, 30);
      }
    }
    escreverCodigo();
  </script>
</body>
</html>
